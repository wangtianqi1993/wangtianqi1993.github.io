[{"title":"python中的多进程与多线程","date":"2017-02-25T04:18:35.000Z","path":"2017/02/25/first-blog/","text":"简介 早已进入多核时代的计算机，怎能不用多线程和多进程进行加速。 我在使用python的过程中，用到过几次多线程和多进程加速，觉得 充分利用CPU节省时间是一种很有“延长生命”的感觉。现将网络上看到的python的 多线程和多进程编程常用的知识点汇总在这里。 进程与线程 线程与进程是操作系统里面的术语，简单来讲，每一个应用程序都有一个自己的进程。 操作系统会为这些进程分配一些执行资源，例如内存空间等。 在进程中，又可以创建一些线程，他们共享这些内存空间，并由操作系统调用， 以便并行计算。 多线程编程 线程的状态创建线程后，其经历的状态变化如下所示: New 创建 Runnable就绪。等待调度 Running运行。 Blocked阻塞。 Dead消亡 线程的类型 主线程 子线程 守护线程 前台线程 python的GILGIL即全局解释器锁，它使得python的多线程无法充分利用 多核的优势，但是对于I/O操作频繁的爬虫之类的程序， 利用多线程带来的优势还是很明显的。 如果要利用多核优势，还是用多进程吧。 创建线程Python提供两个模块进行多线程的操作，分别是thread和threading， 前者是比较低级的模块，用于更底层的操作，一般应用级别的开发不常用。 12345678910111213141516171819202122import timeimport threadingclass MyThread(threading.Thread): def run(self): for i in range(5): print &apos;thread &#123;&#125;, @number: &#123;&#125;&apos;.format(self.name, i) time.sleep(1)def main(): print &quot;Start main threading&quot; # 创建三个线程 threads = [MyThread() for i in range(3)] # 启动三个线程 for t in threads: t.start() print &quot;End Main threading&quot;if __name__ == &apos;__main__&apos;: main() 如下所示：（不同的环境不一样）1234567891011121314Start main threadingthread Thread-1, @number: 0thread Thread-2, @number: 0thread Thread-3, @number: 0End Main threadingthread Thread-1, @number: 1thread Thread-3, @number: 1thread Thread-2, @number: 1thread Thread-3, @number: 2thread Thread-1, @number: 2thread Thread-2, @number: 2thread Thread-2, @number: 3thread Thread-1, @number: 3thread Thread-3, @number: 3 线程合并（join方法）主线城结束后，子线程还在运行，join使得主线程等到子线程结束时才退出12345678910111213def main(): print &quot;Start main threading&quot; threads = [MyThread() for i in range(3)] for t in threads: t.start() # 一次让新创建的线程执行 join for t in threads: t.join() print &quot;End Main threading&quot; 线程同步与互斥锁1mutex = threading.Lock() 在线程中获取锁1mutex.acqure()使用完，释放锁mutex.relase()","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]}]